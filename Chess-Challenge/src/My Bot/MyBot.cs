using ChessChallenge.API;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

// transposition table implementation taken from https://github.com/Selenaut/Chess-Challenge-Selebot

public class MyBot : IChessBot{
	Matrix4x4[,] q_w1 = new Matrix4x4[96, 4];
	Matrix4x4[,] q_w2 = new Matrix4x4[4, 4];
	Matrix4x4[,] q_w3 = new Matrix4x4[4, 1];
	Matrix4x4[,] b1 = new Matrix4x4[1, 4]{
					{new Matrix4x4(-0.29993486404418945f, 0.08653905987739563f, -1.0936377048492432f, 1.0602269172668457f,
									-0.29993486404418945f, 0.08653905987739563f, -1.0936377048492432f, 1.0602269172668457f,
									-0.29993486404418945f, 0.08653905987739563f, -1.0936377048492432f, 1.0602269172668457f,
									-0.29993486404418945f, 0.08653905987739563f, -1.0936377048492432f, 1.0602269172668457f),
					new Matrix4x4(-1.273152232170105f, 1.8579729795455933f, 0.8193477392196655f, -0.9003545045852661f,
									-1.273152232170105f, 1.8579729795455933f, 0.8193477392196655f, -0.9003545045852661f,
									-1.273152232170105f, 1.8579729795455933f, 0.8193477392196655f, -0.9003545045852661f,
									-1.273152232170105f, 1.8579729795455933f, 0.8193477392196655f, -0.9003545045852661f), 
					new Matrix4x4(-2.796793222427368f, -2.0263335704803467f, 1.2354588508605957f, -2.0719003677368164f, 
									-2.796793222427368f, -2.0263335704803467f, 1.2354588508605957f, -2.0719003677368164f,
									-2.796793222427368f, -2.0263335704803467f, 1.2354588508605957f, -2.0719003677368164f,
									-2.796793222427368f, -2.0263335704803467f, 1.2354588508605957f, -2.0719003677368164f),
					new Matrix4x4(-2.890228748321533f, 1.0567190647125244f, -3.4137537479400635f, 1.4811464548110962f,
									-2.890228748321533f, 1.0567190647125244f, -3.4137537479400635f, 1.4811464548110962f,
									-2.890228748321533f, 1.0567190647125244f, -3.4137537479400635f, 1.4811464548110962f,
									-2.890228748321533f, 1.0567190647125244f, -3.4137537479400635f, 1.4811464548110962f)}};
	Matrix4x4[,] b2 = new Matrix4x4[1, 4]{
						{new Matrix4x4(-0.4016995429992676f, -2.076646089553833f, 0.29222989082336426f, -0.2037256956100464f,
									-0.4016995429992676f, -2.076646089553833f, 0.29222989082336426f, -0.2037256956100464f,
									-0.4016995429992676f, -2.076646089553833f, 0.29222989082336426f, -0.2037256956100464f,
									-0.4016995429992676f, -2.076646089553833f, 0.29222989082336426f, -0.2037256956100464f), 
						new Matrix4x4(-1.8449466228485107f, -0.5771762132644653f, 2.004171371459961f, -0.6664741635322571f,
									-1.8449466228485107f, -0.5771762132644653f, 2.004171371459961f, -0.6664741635322571f,
									-1.8449466228485107f, -0.5771762132644653f, 2.004171371459961f, -0.6664741635322571f,
									-1.8449466228485107f, -0.5771762132644653f, 2.004171371459961f, -0.6664741635322571f), 
						new Matrix4x4(0.3953193426132202f, 1.0382074117660522f, 1.3189753293991089f, 2.0706770420074463f,
									0.3953193426132202f, 1.0382074117660522f, 1.3189753293991089f, 2.0706770420074463f,
									0.3953193426132202f, 1.0382074117660522f, 1.3189753293991089f, 2.0706770420074463f,
									0.3953193426132202f, 1.0382074117660522f, 1.3189753293991089f, 2.0706770420074463f), 
						new Matrix4x4(1.263485074043274f, -1.5989949703216553f, -0.282110333442688f, -1.4524286985397339f, 
									1.263485074043274f, -1.5989949703216553f, -0.282110333442688f, -1.4524286985397339f,
									1.263485074043274f, -1.5989949703216553f, -0.282110333442688f, -1.4524286985397339f,
									1.263485074043274f, -1.5989949703216553f, -0.282110333442688f, -1.4524286985397339f)}};
	Matrix4x4[,] b3 = new Matrix4x4[1, 1]{{new Matrix4x4(0.656718909740448f, 0, 0, 0,
														0.656718909740448f, 0, 0, 0,
														0.656718909740448f, 0, 0, 0,
														0.656718909740448f, 0, 0, 0)}};
	
	float w1_S = 0.04472186416387558f;

	float w2_S = 0.04528042674064636f;

	float w3_S = 0.02216847985982895f;
	// bool searchCancelled => searchTimer.MillisecondsElapsedThisTurn > searchMaxTime;
	// int searchMaxTime;
	// Timer searchTimer;
	Board m_board;
	// int moves_searched;
	float[,] m_bits = new float[1, 384];
	int m_depth;

	struct Transposition
	{
		public ulong zobristHash;
		public Move move;
		public float evaluation;
		public sbyte depth;
		public byte flag;
		public float ordering;
	}; 

	private Transposition[] m_TPTable;

	public MyBot(){
		ulong[] w1 = {9474315244148329330, 9045349561769230980, 9188050812050440831, 10052465958875660941, 9188624752841823122, 8901236572650636670, 10488174899226248325, 9978435806584869250, 9621521172311670920, 8680566809553899134, 9549749456011036308, 10345486903063182198, 9981536489285714567, 9980394002416766357, 10196000587833708930, 8686742757609470606, 9391566024670482312, 8677449710483441542, 6960740407329527682, 6453529186544550785, 9912856595237798551, 9474882089737746700, 8178713431084606081, 7746622924026450559, 7385783041812628872, 9968309351870337420, 12215898190474483828, 11713753090343733832, 9264362214494928477, 8322785708191876496, 7530433653449653374, 9115693012700202629, 8969074279394542216, 9327100545762693767, 6815499375449968275, 8040487292249541242, 9976472121901680261, 9258141186511570758, 9907816412494205060, 9188055163036665470, 9117709560124704650, 9327386436065068173, 10056986077217196925, 10344931418116099420, 8541493861494324571, 8249325184512130717, 9260398642966265986, 8323084771379021958, 9616483218721970057, 9544414638276647814, 7391961201595747968, 9119949329637217140, 8971039080871985560, 9766198202306297452, 9691350056497617019, 9188619217115713401, 9472339439015198601, 9831801684714093964, 10416993659056918633, 10561662885180113781, 9908060426648517735, 9401408771399845508, 9116268035571814528, 10124529020323136650, 9692499071867596168, 9908928014723423625, 9048156541824503176, 9048167627168452744, 8394567290602094967, 9190280591434024832, 9187221767431691895, 13078607771073810037, 9403645247424856712, 9907252380359883916, 9408738099067062644, 9910604714038951297, 10412464736100257908, 9762271820982816891, 8467482482621648760, 10125094152136660361, 10487982540843619209, 10416213009944118405, 9625180300117969018, 9833763105919241343, 8182897115793032333, 9120483631808483965, 9836583413287588990, 11421287510358069627, 9334140758225420679, 8033172202666758794, 9610555704446126215, 10053032228941300353, 10060915701557795209, 10282439789887328907, 10196313871304724861, 9765095319246246786, 10773124384285899145, 11999160113640615559, 9841917153355598714, 10124803876657204616, 9191415261443032453, 9208595139159037331, 12790939285511640949, 12574493802250867841, 9262912199444101511, 9616746019283177352, 8324205087863310214, 9838828736594149764, 10512388335534254197, 12227716764171867787, 9333027949194219632, 9188910537247856257, 8975535006030855305, 8827464792522193806, 10417258563914992252, 10125386673802872188, 8972727918266645117, 9983776177577951620, 9260677940260470409, 10413025482634657930, 9329078502605618306, 9980973505275200138, 9840507579179760760, 9335264385574080383, 9403375866287520911, 9836281077721826183, 9765361426982276477, 10271722871407803007, 9849230090102148500, 8890259112937560985, 11578090092476603007, 7749151765472315143, 11024639086160801157, 13015802593016508499, 12078466684507559538, 7597445485497191287, 11917777599704710546, 9272200865877655707, 11280546569722894682, 10056985818852530233, 9974471937633770434, 10844802612291071695, 10265244423905583726, 7382379946272009343, 7393325781711746457, 8823792587029388180, 10052199571333417844, 11426098939571182452, 12062741319704750724, 10130150617236342395, 8249959513649806733, 11421873459860638578, 9542450957892346780, 8753451257829224851, 9119956913727180934, 8838200446068756584, 10561081363721061209, 11290669021377168536, 9904413324818609264, 12859062700595380846, 9052664699017463957, 9770446788419028630, 6308572559312525692, 8396292502446643554, 9190310291517436808, 10560790963264719721, 8823000766772189295, 10841147737101333097, 9187213061719494289, 7509077915724129423, 10058105311234333818, 9332192371964808317, 11072816932935469172, 10700393743188459872, 10986672481753001835, 6660944156945113204, 9043379335651357338, 10054705724309217941, 7540043406670275472, 8906036993390911355, 9969138362281131097, 8974981792650726760, 10625863420596623991, 10768519508842743664, 9482203209604702869, 9043644313860073107, 8977530529105681514, 9698102046591064694, 10780361163782261652, 12227159388718988902, 9399143742716013175, 8823505460745035894, 9986081896712325016, 11214963145331478424, 8255826614282917755, 9409033905879093627, 7387179327363642466, 10565038463270421371, 10264416517771789677, 11271828628040548206, 10496341049126523027, 10342109228978310037, 9840251380185603975, 10054723260745160827, 9912878427263893384, 11067491079370942343, 10911785844648804461, 10981577361462755449, 11197748104894590869, 11207074178223602570, 7825172150612693131, 9551181002686177413, 10188145685053406339, 9477974332442581649, 8319704859396638576, 9688243816459046497, 10274601379730006677, 9698896060866525075, 10201675167395781506, 11136452443881249915, 9193133880499146123, 9551164540581815425, 9395781432518015597, 13866160433149806209, 7884798631508609168, 15597791328679266709, 8691549886839820692, 10552666826617363079, 8378821129422204310, 8979461245804970883, 9472893557744896356, 10839480855948466800, 13885873723172292232, 7246777331689549973, 9984374329619027583, 7245044316963380606, 10080886118904733610, 10777541182477738159, 11273495534995800945, 11127974153489197440, 12347122597303250324, 9911745010777819033, 10909813002611169946, 9125286243316111983, 8596151696723703703, 10860275879844614279, 4211861219079332977, 12784196011132037490, 15087776272308136081, 8106884582141228163, 9409019656386549636, 10199131997822286957, 9637010126144837011, 11578620048991760006, 5437396661262516860, 6518544252188197242, 5928579394374244246, 8758797126513699739, 5586639852371225740, 7316272900710307510, 8177864604838353290, 11128809674519316592, 4070792742944808829, 8823569158382316919, 7024917854257847701, 12490027188583177119, 10427675075620545702, 11291541054791000704, 7961115472051389320, 4996349875597109952, 9256171011663235179, 4643320525193839238, 11258261925480199316, 10326601738554732184, 9905853620863217530, 9985797156773335914, 10054987238375328350, 10053876589644384872, 8104105915063044197, 5149173930723216226, 11278045446823253154, 11282259879134659735, 11784976378009329505, 11569104848005674813, 9982025647944664435, 9119905336551300504, 9327651276399283828, 9617287918762761328, 10269752597945282455, 11864053383159782804, 7895540787717514379, 8687044981859525522, 10701544038326375006, 12141307072687412346, 13002348849186113384, 10485665800637153640, 10057553476858380468, 11062679706225254546, 8976697104073396605, 9196239876675577232, 12072878996665637503, 9903272130685472398, 9328517696125690756, 10841119128172783979, 9968275322477515672, 10272582745132006299, 6954012449038836070, 10630364915254863216, 8381905315285402474, 9557380118483079035, 9039119634463689323, 8030067014476725614, 10489584559065435542, 9264064513717734294, 10559147184992658538, 9624090572407941489, 10054156986486849667, 8759940412483075493, 10046537263580739685, 8896174322682921586, 13581584996440063895, 8826087242412363414, 11857587039447721612, 7895551701163088521, 12784203560091876498, 10988933150657127304, 10768551407531687787, 10192620585925766245, 10845664737161281682, 9911995720197120404, 8542659292146212757, 10274574902196345753, 12219285738824569956, 12142131843245058408, 5869745489900042340, 6878273621550210148, 7234907013013802391, 9484515473766065045, 8614730221973841518, 10124832485601748343, 7952669122359889548, 9117138875222297467, 9834298564270194797, 10044556024963429227, 11342159086661838476, 8605102997683929744, 8322269981975618189, 9480541726957282705, 9408751302166221408, 9839113214302654077, 7237996459438734211, 10841174120934243179, 10037831484797062548, 10998513315328999320, 9046500759234782590, 10488500259725222516, 12139319378601215096, 9622370063940946579, 10552607272514910044, 6805649783067605871, 9039714655105146773, 10259932872901614745, 9556532343711964319, 10634021942418972873, 11283915571883645060, 12226016785817896336, 6950331215771826307, 9977033795275621221, 6682697092608775826, 7966496758294338708, 10407973295024086905, 9761449349056991100, 8396827890904039039, 8255538508183206033, 8605387560538512232, 10626098625251881080, 8549100479935187860, 5817671691076902284, 8687329892894613902, 6217943368545055379, 6372252111421603195, 6235408890789855668, 8679434239377573741, 9969732016451989851, 9330792809154448036, 10055022426388466849, 9338393564966132353, 9554287131775836797, 9046472253200111000, 9042540296474498164, 10405757603566561646, 10693691094415612005, 9837421374476090271, 6733048141176281498, 9843078206965915775, 10706913868733916528, 9188644509909423952, 12074892374555333780, 9468129267342085224, 10186744816942227053, 8614158630662143649, 9905824200689031583, 8260052827794219116, 10707772810603896958, 7672616862106622309, 9548356365836457571, 10910478516195518600, 9108384456063946603, 9474879410113778851, 10048512209367693214, 9194833759967681912, 8760795621706405444, 8902106170601085271, 9835470772616993129, 11052797115257881715, 10836917881457701500, 10842318927723274649, 10844823627878142631, 7176655732376642939, 10925071256132689795, 8034011189631227770, 9911454674895409300, 8674605175952018535, 8026971906775743090, 11128562481600299935, 10914923000163167125, 10706917368999284329, 8622300204661641785, 10130454177321493351, 12863874340963456390, 9467548712770767204, 11341871981048455798, 11637458291838974890, 10337311058884859293, 8186029431184466308, 9412708448238279547, 10125678078559950987, 8894473656781213296, 8388965249296467335, 12711299333691834731, 8179515083106260129, 10047410524838929827, 9770728091730744718, 11717135282669328751, 10342976645036941429, 10702434561507631735, 10979942405739601524, 11344153394344006514, 9112345120355027629, 11421560370268507541, 8479900448484138622, 10061491772587286925, 7469392173214836604, 8824395054941507953, 9395532968575539829, 10981876382301850978, 9980144568030363555, 9612530565271226011, 10852717919338272614, 12004518012897431147, 9407070273442784377, 12582950133342903934, 12349308206603472495, 8314352377047775845, 8023029306582531740, 12211073525599077272, 9766507130833446805, 10930126836300812419, 5220372968400194909, 8255540612662073456, 10980770329271639155, 9974793068674392167, 9547498842094863265, 8321368574772344216, 10414178875533465980, 8844676478590884982, 9624096031647579007, 14953805139383718517, 9394376234762532980, 8893060548617662053, 8757128157921446563, 9482507808549933725, 8483271336168038544, 10857509668471808134, 5007070899377716864, 7309857335085947004, 10048825394605949282, 11846036476269993836, 12289629190237952663, 9038627318803505314, 10852431015571596156, 9991413269597757545, 10845184069737558916, 10418454867124205679, 9755520776200490349, 10768815294968858719, 9188644677531373992, 10994593625279203751, 9558500417200822397, 9485318083214745728, 7310340033823282535, 7596314070368295294, 9758614754861812846, 9541888896790006377, 10272292542935376546, 9762550129898262688, 10060370391020312949, 9774951294269299294, 8899555337531268995, 11427483305913258361, 10981884125642066539, 10692807190062599269, 9112921383931702720, 12206867949287540409, 2060842614155683786, 9706868520647704731, 9322928865784208049, 13009379259730206343, 8588817825882026074, 8951961317795796817, 13307747381070044350, 15314953183722502826, 7543155090210461838, 6041479303947667529, 11710399790583429723, 9686902592242821701, 9961580086983631666, 12132582234325285720, 9051838089607816654, 10844259694710197179, 6681560072733832315, 9487320259111008901, 11629596478991667813, 11554453689973054340, 11984172451427013221, 9457727801877763673, 12114598041986176723, 13007425762529742536, 10425469876221950059, 10784354855196802151, 11488872240327931022, 11130019275147686477, 9602381741056628292, 10257614823413336928, 11945136963057458621, 12070088775589985981, 5539048774617445527, 5817714396526851198, 9325170808629410661, 12569451381830431353, 8090369759998090834, 10828520910953091155, 11699658846067588288, 8730947755738833597, 7834489321903206276, 9269723494112208458, 11793989019373583991, 12933678778233305998, 9673796156190247247, 10105324740295412562, 14172434116545712333, 10623297461591713484, 8767019230094077040, 9991991796678768008, 9466465710712202067, 10419271692699088510, 10539734091472282476, 8520977966468725341, 11211850637984114880, 9328251953617211840, 8985998877235654751, 8696643718203945041, 12071807939733796438, 14091960432374691419, 9818245566373908566, 8881748639543219284, 10469616577550056652, 10835565920244305103, 6393618877048140162, 7759623691049153392, 10263024789805373539, 11423830715985999737, 7444615525391113054, 8380472544591640924, 10768578178515563453, 10841714329741067705, 7330088272750816885, 8479909064240182633, 12219032658110694758, 12799139288664491915, 12991598911650027084, 16951937527466714968, 17929877743200409551, 16187796096704868556, 8700296509758746226, 8768976447277150845, 12946897136230766998, 10553859668236025987, 9391016105986780511, 10396972460025087841, 10479733188466011856, 8182638877617407152, 7261127955054902126, 8192537513623665988, 10634903635317013886, 10995490626147825514, 11551327799315760489, 13421408942471212630, 15596386284549021629, 12859073060442770896, 8622340989803279468, 7618591245680291698, 13876056252130500748, 9764823722678464123, 12195927339380350282, 9463054961501698655, 8893919661044371628, 12222353392942359966, 7400456934803615088, 7116446436899927651, 11207958268019713665, 12941841616750625630, 10111012591857602106, 6428203826412558165, 14965056652646449361, 8974751367838272722, 9772721398136223139, 6463121291963116662, 6883923057984058728, 9620978232995650681, 14211831362143626599, 7948977958508791129, 7658761283966032040, 10048800340919332251, 8840765558730961519, 11541816988728802333, 8111191263004050834, 15466099376723238012, 10831862310095517014, 13203551566356907573, 3191702603736187027, 9401131780249116054, 10624979418196122706, 14152166406798212957, 11770886132252050329, 10768809973590688647, 7320915205650604156, 11424905995073388676, 8314600986617338765, 8749775572971907972, 9832649326373274247, 8750953248340417694, 8678861419958338436, 10485647053391498355, 9408170785275287430, 9407044871996867967, 6806237068942996873, 8531308144317060237, 11991524963480341854, 7170706412934035793, 8609371391210390425, 7813622566621121143, 9260438242313396601, 10198562441588542860, 7451046766136883087, 6153745065096934027, 10417243204859758461, 8896461419099885210, 9828138008807897729, 10050191000800235620, 9262384429585635195, 10558285236494957448, 11356234969912999813, 10056100970355713681, 10405146244436161632, 8184851807370705793, 8825523033545080187, 7453340312849125984, 7817804258484265369, 9260113955437975449, 8684753766491646865, 8895036464562669449, 9190856701636213109, 8539523595811648647, 9260122523828654700, 9909764730235751296, 9187513185375523730, 8610487318219690130, 10202464616374897801, 8320229386942840718, 9615876288054784903, 9189171154388089479, 6438900923958919550, 8107466091535372688, 8391517400469902214, 10051311518927791261, 8395972539578550151, 8247639616191164293, 10061164178066274185, 10124498268123523730, 8250189336745251189, 8681414437354446930, 9331351352287994262, 9546389412581321130, 11495269219899113349, 9985495788010766482, 8182073586185244553, 9191682494678919812, 9755520999541468572, 8766962133666730140, 6372497383900757142, 11489116568298492831, 9479081674635181457, 11063520780797253511, 9191977159534930568, 8836187338609746290, 9192857860127625858, 6812685699791625101, 9260147009271013796, 9546377391085754015, 9407309889078995068, 9766518182069181072, 8252693121806603169, 7964474737488131463, 14729552208892110000, 9548111251803255705, 9980445743904825742, 9549196448638473373, 12434887776239262345, 12794881047029644935, 10559669590488283794, 9988276526050343806, 13374447983167313300, 7752275573166015115, 9332476122685673889, 11564836600990952355, 10276300090667479672, 7964790194078266497, 9123584641646231935, 8184597970408801182, 8195872754083987356, 9845315769283677841, 8175306178465277575, 10844286975691882388, 9622669059027996280, 11782440801433128827, 9334697085021293458, 10920823984615491451, 8331543404091048602, 7963334509350646922, 8683934674000312967, 12286810943731687036, 8181832625365295732, 7827419397609267583, 8325072560174238325, 9698094391448468112, 13092361782480833420, 12515645788959313524, 11709201275512842102, 9476549408892807321, 11423821868704959862, 15965421704977945203, 9118526544226386563, 8974421256217002381, 9488077925330941595, 8032295878460143753, 6953127337814428814, 9115674239448012403};
		ulong[] w2 = {15412388719815229401, 16277085315698646749, 15772697576499040474, 14467498105195393747, 16564198575418961911, 13755080446002122449, 14404443320403288810, 12603832420641528517, 16275416291071089883, 15772687667925870558, 16276535594326943195, 16489613208125301465, 16275973778128165853, 16706626012307710445, 13249558104051474396, 14188830177208951271, 16205597286047337691, 15844183407311057626, 16059243462064792805, 15983237517325621475, 16491580256036048081, 16997394074198076149, 16348873563880743888, 16710840474116808424, 16349684968900194522, 16347754234988389321, 16206449449802910938, 16132412688395720920, 16059479779771545587, 16132982312343300069, 15270817633925783289, 14332100979009312233};
		ulong[] w3 = {5980780307933036544, 12538021364428177408, 11961560610296037376, 12393906178801795072, 12321848583354580992, 11817445424954867712, 13042424523733860352, 9367487227866644480};
		ulong[][] weights = {w1, w2, w3};
		int[] rows = {8, 8, 2};
		Matrix4x4[][,] quantized_weights = {q_w1, q_w2, q_w3};
		float[] zeros = {-132.43197631835938f, -224.8640899658203f, -169.06996154785156f};
		int count = 0;
		foreach(ulong[] w in weights){
			for(int x = 0; x < w.Length; x+=2){
				// convert 64 bit int into a binary string with padding to ensure same length
				string one = Convert.ToString((long) w[x], 2).PadLeft(64, '0');
				string two = Convert.ToString((long) w[x+1], 2).PadLeft(64, '0');

				float[] a = new float[8];
				float[] b = new float[8];
				for(int i = 0; i < 8; i++){
					// a[i] = Convert.ToInt32(one.Substring(i*8, 8), 2) + zeros[count];
					// b[i] = Convert.ToInt32(two.Substring(i*8, 8), 2) + zeros[count];
					a[i] = Convert.ToInt32(one.Substring(i*8, 8), 2) + zeros[count];
					b[i] = Convert.ToInt32(two.Substring(i*8, 8), 2) + zeros[count];
				}
				// every eight bits is a number, extract it and write to quantized weights
				Matrix4x4 sun = new (a[0], a[1], a[2], a[3],
									 a[4], a[5], a[6], a[7],
									 b[0], b[1], b[2], b[3],
									 b[4], b[5], b[6], b[7]);
				// quantized_weights[count][(8 * x + y) / rows[count], (8 * x + y) % rows[count]] = Convert.ToInt32(str.Substring(y*8, 8), 2) + zeros[count];
				quantized_weights[count][x/rows[count], (x % rows[count])/2] = sun;
			}
			count++;
		}
		m_TPTable = new Transposition[0x800000]; // intializes transposition table with 8 million spaces
	}
	public Move Think(Board board, Timer timer){
		m_board = board;
		// moves_searched = 0;
		InitalizeBits();
		// Move[] moves = board.GetLegalMoves();
		// for(int i = 0; i < 10; i++){
		//     moves = m_board.GetLegalMoves();
		//     m_board.MakeMove(moves[i]);
		//     m_board.UndoMove(moves[i]);
		//     Console.WriteLine(m_board.GetFenString());
		//     UpdateBits(moves[i]);
		//     UndoBits(moves[i]);
		//     Console.Write("(");
		//     for(int x = 0; x < m_bits.Length; x++){
		//         Console.Write(m_bits[0, x] + ", ");
		//     }
		//     Console.Write(")");
		//     Console.WriteLine();
		// }
		// searchMaxTime = timer.MillisecondsRemaining / 50;
		// searchTimer = timer;
		// Console.WriteLine(q_w1[0, 0]);
		// set the best move to the index of the zobristkey
		// we do the bitwise and weirdness because the entire zobrist key is 64 bits
		// or in other words would require an array with 2^64 elements which we
		// don't have the memory to accomadate so instead we do an and operation 
		// with 23 1's in binary to only get the first 23 numbers of the zobrist
		// key which we then use to index into an array of only 2^23 elements
		// which is much more managable
		// Transposition bestMove = m_TPTable[board.ZobristKey & 0x7FFFFF];
		// for(int depth = 1; depth < 5; depth++){
		m_depth = 3;
		Search(m_depth, -100, 100);
		Transposition bestMove = m_TPTable[board.ZobristKey & 0x7FFFFF];
			// Console.WriteLine(depth + " " + timer.MillisecondsElapsedThisTurn + " " + bestMove.move + " " + bestMove.evaluation);

		//     if(searchCancelled){
		//         break;
		//     }
		// }
		// Console.WriteLine(bestMove.evaluation);
		// Console.WriteLine(m_board.GetFenString());
		// Move[] moves = m_board.GetLegalMoves();
		// OrderMoves(ref moves, 0);
		// Console.WriteLine(moves_searched);
		return bestMove.move;
	}
	Matrix4x4[,] Eval(Matrix4x4[,] input){
		// moves_searched++;
		// Console.WriteLine(PLUG(MatMul(PLUG(MatMul(PLUG(MatMul(input, q_w1), w1_S, b1), q_w2), w2_S, b2), q_w3), w3_S, b1)[0, 0]);
		return PLUG(MatMul(PLUG(MatMul(PLUG(MatMul(input, q_w1), w1_S, b1, true), q_w2), w2_S, b2, true), q_w3), w3_S, b3, false);
	}
	void InitalizeBits(){
		Array.Clear(m_bits);
		PieceType[] types = {PieceType.Pawn, PieceType.Knight, PieceType.Bishop, PieceType.Rook, PieceType.Queen, PieceType.King};
		bool[] colors = {true, false};
		int count = 0;
		foreach(PieceType type in types){
			foreach(bool color in colors){
				string c = new String(Convert.ToString((long)m_board.GetPieceBitboard(type, color), 2).PadLeft(64, '0').Reverse().ToArray());
				for(int i = 0; i < 64; i++)
					if(int.Parse(c.Substring(i, 1)) != 0)
						m_bits[0, count * 64 + i] = (Convert.ToInt32(color) * 2 - 1) *  int.Parse(c.Substring(i, 1));
			}
			count++; 
		}
	}
	void UpdateBits(Move move){
		int a;
		if(m_board.IsWhiteToMove){
			a = 1;
		}
		else{
			a = -1;
		}
		// we always want to set the square we are moving from to 0
		m_bits[0, move.StartSquare.Index + 64 * ((int)move.MovePieceType - 1)] = 0;

		if(move.IsCapture){
			// set the piece we captured to zero
			m_bits[0, move.TargetSquare.Index + 64 * ((int)move.CapturePieceType - 1)] = 0;
		}
		if(move.IsPromotion){
			m_bits[0, move.TargetSquare.Index + 64 * ((int)move.PromotionPieceType - 1)] = a * -1;
		}
		else{
			m_bits[0, move.TargetSquare.Index + 64 * ((int)move.MovePieceType - 1)] = -1 * a;
		}
		if(move.IsCastles){
			if(!m_board.IsWhiteToMove){
				if(move.TargetSquare.Index == 58){
					m_bits[0, 56 + 64 * (int)PieceType.Rook] = 0;
					m_bits[0, 58 + 64 * (int)PieceType.Rook] = -1;
				}
				if(move.TargetSquare.Index == 62){
					m_bits[0, 63 + 64 * (int)PieceType.Rook] = 0;
					m_bits[0, 61 + 64 * (int)PieceType.Rook] = -1;
				}
			}
			else{
				if(move.TargetSquare.Index == 2){
					m_bits[0, 0 + 64 * (int)PieceType.Rook] = 0;
					m_bits[0, 3 + 64 * (int)PieceType.Rook] = 1;
				}
				if(move.TargetSquare.Index == 6){
					m_bits[0, 7 + 64 * (int)PieceType.Rook] = 0;
					m_bits[0, 5 + 64 * (int)PieceType.Rook] = 1;
				}
			}
		}
	}
	void UndoBits(Move move){
		int a;
		if(m_board.IsWhiteToMove){
			a = 1;
		}
		else{
			a = -1;
		}
		m_bits[0, move.StartSquare.Index + 64 * ((int)move.MovePieceType - 1)] = a * -1;

		if(move.IsCapture){
			m_bits[0, move.TargetSquare.Index + 64 * ((int)move.CapturePieceType - 1)] = a;
		}
		if(move.IsPromotion){
			m_bits[0, move.TargetSquare.Index + 64 * ((int)move.PromotionPieceType - 1)] = 0;
		}
		else{
			m_bits[0, move.TargetSquare.Index + 64 * ((int)move.MovePieceType - 1)] = 0;
		}
		if(move.IsCastles){
			if(!m_board.IsWhiteToMove){
				if(move.TargetSquare.Index == 58){
					m_bits[0, 56 + 64 * (int)PieceType.Rook] = -1;
					m_bits[0, 58 + 64 * (int)PieceType.Rook] = 0;
				}
				if(move.TargetSquare.Index == 62){
					m_bits[0, 63 + 64 * (int)PieceType.Rook] = -1;
					m_bits[0, 61 + 64 * (int)PieceType.Rook] = 0;
				}
			}
			else{
				if(move.TargetSquare.Index == 2){
					m_bits[0, 0 + 64 * (int)PieceType.Rook] = 1;
					m_bits[0, 3 + 64 * (int)PieceType.Rook] = 0;
				}
				if(move.TargetSquare.Index == 6){
					m_bits[0, 7 + 64 * (int)PieceType.Rook] = 1;
					m_bits[0, 5 + 64 * (int)PieceType.Rook] = 0;
				}
			}
		}
	}
	// float Quiesce(float alpha, float beta){
	//     float stand_pat = Eval(BoardToBit());
	//     float score;
	//     if(stand_pat >= beta) return beta;
	//     if(alpha < stand_pat) alpha = stand_pat;

	//     Move[] moves = m_board.GetLegalMoves(capturesOnly: !m_board.IsInCheckmate());
	//     foreach(Move move in moves){
	//         m_board.MakeMove(move);
	//         score = -Quiesce(-beta, -alpha);
	//         m_board.UndoMove(move);
	//         if(score >= beta) return beta;
	//         if(score > alpha) alpha = score;
	//     }
	//     return alpha;
	// }
	float Search(int depth, float alpha, float beta){
		// if(searchCancelled) return 0;

		float startingAlpha = alpha;
		
		//See if we've checked this board state before
		ref Transposition transposition = ref m_TPTable[m_board.ZobristKey & 0x7FFFFF];
		if(transposition.zobristHash == m_board.ZobristKey && transposition.depth >= depth){
			//If we have an "exact" score (a < score < beta) just use that
			if(transposition.flag == 1) return transposition.evaluation;
			//If we have a lower bound better than beta, use that
			if(transposition.flag == 2 && transposition.evaluation >= beta)  return transposition.evaluation;
			//If we have an upper bound worse than alpha, use that
			if(transposition.flag == 3 && transposition.evaluation <= alpha) return transposition.evaluation;
		}
		
		Move[] moves;
		
		if(m_board.IsDraw()) return 0;
		// if we have reached our depth evaluate the position
		// evaluation function produces values close to 1 for winning positions
		// and values close to 0 for losing positions regardless of color
		if(depth == 0 || (moves = m_board.GetLegalMoves()).Length == 0) {
			if (m_board.IsInCheckmate())
				return -9999999;
			return transposition.evaluation; 
		}

		OrderMoves(ref moves, depth);
		
		float bestEvaluation = -1000;
		Move bestMove = Move.NullMove;

		foreach(Move move in moves){
			m_board.MakeMove(move);
			UpdateBits(move);
			float evaluation = -Search(depth - 1, -beta, -alpha);
			UndoBits(move);
			m_board.UndoMove(move);

			// if(searchCancelled) return 0;

			if(bestEvaluation < evaluation){
				bestEvaluation = evaluation;
				bestMove = move;
			}
			alpha = Math.Max(alpha, bestEvaluation);
			if (alpha >= beta) break;
		}

		// we know this is the best move from this position so update the transposition table
		transposition.evaluation = bestEvaluation;
		transposition.zobristHash = m_board.ZobristKey;
		transposition.move = bestMove;
		if(bestEvaluation < startingAlpha) 
			transposition.flag = 3;
		else if(bestEvaluation >= beta) 
			transposition.flag = 2;
		else transposition.flag = 1;
		transposition.depth = (sbyte)depth;

		return bestEvaluation;

	}
	void OrderMoves(ref Move[] moves, int depth){
		// Console.WriteLine(m_board.IsWhiteToMove);
		// Console.WriteLine(m_board.GetFenString());
		// Console.Write("(");
		// for(int x = 0; x < m_bits.Length; x++){
		//     Console.Write(m_bits[0, x] + ", ");
		// }
		// Console.Write(")");
		// Console.WriteLine();
		float[] movePriorities = new float[moves.Length];
		List<int> indices_to_evaluate = new List<int>();
		int count = 0;
		// loop through all legal moves and if we have already evaluated it
		// add it to the move priorities, if not then add it to indices to evaluate
		for(int i = 0; i < moves.Length; i++){
			m_board.MakeMove(moves[0]);
			ref Transposition transposition = ref m_TPTable[m_board.ZobristKey & 0x7FFFFF];
			// this might break because it is concievable the model will output 0
			// in practice this would be extremely unlikely but the fact that the final
			// layer has a relu means if the network outputs anything below 0 it will
			// be rounded up so
			if(transposition.ordering != 0){
				movePriorities[i] = transposition.ordering;
			}
			else{
				indices_to_evaluate.Add(i);
				count++;
			}
			m_board.UndoMove(moves[0]);
		}
		// we need to do this terrible temp_bits non-sense as an intermediate because model input bitboards
		// are stored as 2d array, not really a way to store it work with matrices that i can think of without
		// some kind of row/col shift operation which you can then use to add them
		Matrix4x4[,] input_to_model = new Matrix4x4[(int)Math.Ceiling((double)count/4), 96];
		float[,] temp_bits = new float[count, 384];
		foreach(int index in indices_to_evaluate){
			// InitalizeBits();
			m_board.MakeMove(moves[index]);
			UpdateBits(moves[index]);
			for(int col = 0; col < 384; col++){
				temp_bits[index, col] = m_bits[0, col];
			}
			UndoBits(moves[index]);
			m_board.UndoMove(moves[index]);
		}
		for(int row = 0; row < input_to_model.GetLength(0); row++){
			for(int i = 0; i < input_to_model.GetLength(1); i++){
				if(row*4+0 < moves.Length){
					input_to_model[row, i].M11 = temp_bits[row*4+0, 4*i+0];
					input_to_model[row, i].M12 = temp_bits[row*4+0, 4*i+1]; 
					input_to_model[row, i].M13 = temp_bits[row*4+0, 4*i+2]; 
					input_to_model[row, i].M14 = temp_bits[row*4+0, 4*i+3];
				}
				if(row*4+1 < moves.Length){
					input_to_model[row, i].M21 = temp_bits[row*4+1, 4*i+0];
					input_to_model[row, i].M22 = temp_bits[row*4+1, 4*i+1];
					input_to_model[row, i].M23 = temp_bits[row*4+1, 4*i+2];
					input_to_model[row, i].M24 = temp_bits[row*4+1, 4*i+3];
				}
				if(row*4+2 < moves.Length){
					input_to_model[row, i].M31 = temp_bits[row*4+2, 4*i+0];
					input_to_model[row, i].M32 = temp_bits[row*4+2, 4*i+1];
					input_to_model[row, i].M33 = temp_bits[row*4+2, 4*i+2];
					input_to_model[row, i].M34 = temp_bits[row*4+2, 4*i+3];
				}
				if(row*4+3 < moves.Length){
					input_to_model[row, i].M41 = temp_bits[row*4+3, 4*i+0];
					input_to_model[row, i].M42 = temp_bits[row*4+3, 4*i+1];
					input_to_model[row, i].M43 = temp_bits[row*4+3, 4*i+2];
					input_to_model[row, i].M44 = temp_bits[row*4+3, 4*i+3];
				}
			}
		}

		// pass to neural network eval
		Matrix4x4[,] logits = Eval(input_to_model);

		// unpack network evals into move priorities
		for(int i = 0; i < logits.GetLength(0); i++){
			if(i*4+0 < moves.Length){
				movePriorities[i*4+0] = logits[i, 0].M11;
			}
			if(i*4+1 < moves.Length){
				movePriorities[i*4+1] = logits[i, 0].M21;
			}
			if(i*4+2 < moves.Length){
				movePriorities[i*4+2] = logits[i, 0].M31;
			}
			if(i*4+3 < moves.Length){
				movePriorities[i*4+3] = logits[i, 0].M41;
			}
		}
		
		// write to transposition table so we don't have to recompute already seen positions
		for(int i = 0; i < moves.Length; i++){
			m_board.MakeMove(moves[i]);
			ref Transposition transposition = ref m_TPTable[m_board.ZobristKey & 0x7FFFFF];
			if(depth == 1){
				if(m_board.IsWhiteToMove){
					transposition.evaluation = movePriorities[i];
				}
				else{
					transposition.evaluation = 1 - movePriorities[i];
				}
				transposition.flag = 1;
			}
			transposition.ordering = movePriorities[i];
			m_board.UndoMove(moves[i]);
			// Console.WriteLine(moves[i] + " " + movePriorities[i]);
		}
		Array.Sort(movePriorities, moves);
		if(m_board.IsWhiteToMove){
			Array.Reverse(moves);
		}
		// Console.WriteLine();
		// Console.WriteLine(moves.Length);
		// Console.WriteLine(input.GetLength(0) + " " + input.GetLength(1));
		// Console.WriteLine();
	}
	static Matrix4x4[,] MatMul(Matrix4x4[,] a, Matrix4x4[,] b){
		int rowsA = a.GetLength(0);
		int colsA = a.GetLength(1);
		int colsB = b.GetLength(1);

		Matrix4x4[,] c = new Matrix4x4[rowsA, colsB];

		for (int row = 0; row < rowsA; row++){
			for (int col = 0; col < colsB; col++){
				Matrix4x4 z = new();
				for (int i = 0; i < colsA; i++){
					z += a[row, i] * b[i, col];
				}
				c[row, col] = z;
			}
		}

		return c;
	}
	Matrix4x4[,] PLUG(Matrix4x4[,] a, float scale, Matrix4x4[,] bias, bool hasReLU){
		for(int row = 0; row < a.GetLength(0); row++){
			for(int col = 0; col < a.GetLength(1); col++){
				a[row, col] *= scale;
				a[row, col] += bias[0, col];
			}
		}
		if(hasReLU){
			for(int row = 0; row < a.GetLength(0); row++){
				for(int i = 0; i < a.GetLength(1); i++){
					a[row, i].M11 = Math.Max(0, a[row, i].M11);
					a[row, i].M12 = Math.Max(0, a[row, i].M12);
					a[row, i].M13 = Math.Max(0, a[row, i].M13);
					a[row, i].M14 = Math.Max(0, a[row, i].M14);

					a[row, i].M21 = Math.Max(0, a[row, i].M21);
					a[row, i].M22 = Math.Max(0, a[row, i].M22);
					a[row, i].M23 = Math.Max(0, a[row, i].M23);
					a[row, i].M24 = Math.Max(0, a[row, i].M24);
					
					a[row, i].M31 = Math.Max(0, a[row, i].M31);
					a[row, i].M32 = Math.Max(0, a[row, i].M32);
					a[row, i].M33 = Math.Max(0, a[row, i].M33);
					a[row, i].M34 = Math.Max(0, a[row, i].M34);

					a[row, i].M41 = Math.Max(0, a[row, i].M41);
					a[row, i].M42 = Math.Max(0, a[row, i].M42);
					a[row, i].M43 = Math.Max(0, a[row, i].M43);
					a[row, i].M44 = Math.Max(0, a[row, i].M44);
				}
			}
		}
		return a;
	}
	void PrintMatrix4x4(Matrix4x4[,] a){
		for(int r1 = 0; r1 < a.GetLength(0); r1++){
			for(int c1 = 0; c1 < a.GetLength(1); c1++){
				Matrix4x4 a_ = a[r1, c1];
				Console.WriteLine(a_.M11 + " " + a_.M12 + " " + a_.M13 + " " + a_.M14 + " ");
				Console.WriteLine(a_.M21 + " " + a_.M22 + " " + a_.M23 + " " + a_.M24 + " ");
				Console.WriteLine(a_.M31 + " " + a_.M32 + " " + a_.M33 + " " + a_.M34 + " ");
				Console.WriteLine(a_.M41 + " " + a_.M42 + " " + a_.M43 + " " + a_.M44 + " ");
			}
		}
	}
}